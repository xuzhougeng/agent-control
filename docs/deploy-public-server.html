<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deployment Guide - Agent Control</title>
    <meta name="description" content="Step-by-step guide to deploying Agent Control in production environments.">
    <link rel="stylesheet" href="assets/css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <style>
        .doc-content {
            max-width: 900px;
            margin: 0 auto;
            padding: 4rem 1.5rem;
            color: #d4d4d4;
        }
        .doc-content h1, .doc-content h2, .doc-content h3 {
            color: #fff;
            margin-top: 2rem;
            margin-bottom: 1rem;
        }
        .doc-content h1 { font-size: 2.5rem; border-bottom: 1px solid #333; padding-bottom: 1rem; }
        .doc-content h2 { font-size: 1.8rem; border-bottom: 1px solid #333; padding-bottom: 0.5rem; }
        .doc-content h3 { font-size: 1.4rem; color: #fff; margin-top: 1.5rem; }
        .doc-content p { line-height: 1.7; margin-bottom: 1.2rem; }
        .doc-content code { background: #2d2d2d; padding: 0.2rem 0.4rem; border-radius: 4px; font-family: 'JetBrains Mono', monospace; font-size: 0.9em; color: #e06c75; }
        .doc-content pre { background: #1e1e1e; padding: 1rem; border-radius: 8px; overflow-x: auto; margin-bottom: 1.5rem; border: 1px solid #333; }
        .doc-content pre code { background: none; color: inherit; padding: 0; }
        .doc-content table { width: 100%; border-collapse: collapse; margin-bottom: 1.5rem; }
        .doc-content th, .doc-content td { padding: 0.75rem; border: 1px solid #333; text-align: left; }
        .doc-content th { background: #252525; color: #fff; }
        .doc-content a { color: #3b82f6; text-decoration: none; }
        .doc-content a:hover { text-decoration: underline; }
        .doc-content ul { padding-left: 1.5rem; margin-bottom: 1.5rem; }
        .doc-content li { margin-bottom: 0.5rem; }
        .mermaid { background: #000; padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem; text-align: center; }
        .back-link { display: inline-flex; align-items: center; color: #888; margin-bottom: 2rem; font-weight: 500; }
        .back-link:hover { color: #fff; text-decoration: none; }
        .back-link i { margin-right: 0.5rem; }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <div class="logo">
                <a href="index.html" style="color: inherit; text-decoration: none; display: flex; align-items: center; gap: 0.5rem;">
                    <i class="fas fa-network-wired"></i> Agent Control
                </a>
            </div>
            <nav>
                <ul>
                    <li><a href="index.html#features">Features</a></li>
                    <li><a href="index.html#architecture">Architecture</a></li>
                    <li><a href="deploy-public-server.html" style="color: #fff;">Docs</a></li>
                    <li><a href="https://github.com/xuzhougeng/agent-control" target="_blank"><i class="fab fa-github"></i> GitHub</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <div class="doc-content" id="content">
        <a href="index.html" class="back-link"><i class="fas fa-arrow-left"></i> Back to Home</a>
        <div id="markdown-body">
            <!-- Loading content... -->
        </div>
    </div>

    <footer>
        <div class="social-links">
            <a href="https://github.com/xuzhougeng/agent-control"><i class="fab fa-github"></i></a>
        </div>
        <p>&copy; 2026 Agent Control. MIT License.</p>
    </footer>

    <!-- Hidden markdown content source -->
    <script type="text/markdown" id="markdown-source">
# 公网服务器部署方案（完整）

> 本页为完整合并版，包含 Part 1/Part 2/Part 3 的全部内容。

---

# 公网服务器部署（Part 1）：方案 A 直连（无 TLS）

> 适用：测试、内部网络、快速验证。  
> 若你要上生产或公网长期运行，请改用 Part 2 的 TLS 方案。

## 前置条件

- 公网服务器可被访问（示例 IP：`1.2.3.4`）
- 具备 `sudo` 权限
- 已准备 `cc-control`、`cc-agent` 源码

## A.1 编译与上传

```bash
# 编译
cd cc-control
CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o cc-control ./cmd/cc-control
cd ../cc-agent
CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o cc-agent ./cmd/cc-agent

# 上传 control 到公网服务器
scp cc-control root@1.2.3.4:/opt/cc-control/
scp -r ../ui root@1.2.3.4:/opt/cc-control/ui
```

## A.2 生成 Admin Token

```bash
ADMIN_TOKEN=$(openssl rand -hex 32)
echo "ADMIN_TOKEN=$ADMIN_TOKEN"
```

## A.3 公网服务器启动 cc-control

关键点：监听公网地址 `0.0.0.0:18080`。

```bash
/opt/cc-control/cc-control \
  -addr 0.0.0.0:18080 \
  -ui-dir /opt/cc-control/ui \
  -admin-token "$ADMIN_TOKEN" \
  -audit-path /opt/cc-control/audit.jsonl \
  -offline-after-sec 30
```

Systemd（可选）`/etc/systemd/system/cc-control.service`：

```ini
[Unit]
Description=CC Control Plane
After=network.target

[Service]
Type=simple
User=cc
Group=cc
WorkingDirectory=/opt/cc-control
ExecStart=/opt/cc-control/cc-control \
  -addr 0.0.0.0:18080 \
  -ui-dir /opt/cc-control/ui \
  -admin-token ${ADMIN_TOKEN} \
  -audit-path /opt/cc-control/audit.jsonl \
  -offline-after-sec 30
EnvironmentFile=/opt/cc-control/.env
Restart=always
RestartSec=3

[Install]
WantedBy=multi-user.target
```

可选：若需 Pending Approvals 自动识别，增加 `-enable-prompt-detection`。

## A.3.1 创建 UI/Agent Token（Admin API）

```bash
# UI token（owner），返回 tenant_id
curl -X POST http://1.2.3.4:18080/admin/tokens \
  -H "Authorization: Bearer $ADMIN_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"type":"ui","role":"owner"}'

# Agent token（同 tenant_id）
curl -X POST http://1.2.3.4:18080/admin/tokens \
  -H "Authorization: Bearer $ADMIN_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"type":"agent","tenant_id":"<tenant_id>"}'
```

放行端口：

```bash
ufw allow 18080/tcp
ufw enable
```

## A.4 内网机器启动 cc-agent

```bash
/opt/cc-agent/cc-agent \
  -control-url ws://1.2.3.4:18080/ws/agent \
  -agent-token "<agent-token>" \
  -server-id srv-gpu-01 \
  -allow-root /home/deploy/repos \
  -claude-path /path/to/ai-cli
```

Systemd（可选）`/etc/systemd/system/cc-agent.service`：

```ini
[Unit]
Description=CC Agent
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
User=deploy
Group=deploy
WorkingDirectory=/opt/cc-agent
ExecStart=/opt/cc-agent/cc-agent \
  -control-url ws://1.2.3.4:18080/ws/agent \
  -agent-token ${AGENT_TOKEN} \
  -server-id ${SERVER_ID} \
  -allow-root /home/deploy/repos \
  -claude-path /path/to/ai-cli
EnvironmentFile=/opt/cc-agent/.env
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
```

`/opt/cc-agent/.env`（600）：

```bash
AGENT_TOKEN=<agent-token-from-admin-api>
SERVER_ID=srv-gpu-01
```

## A.5 验证

```bash
# agent 侧
journalctl -u cc-agent -f

# 浏览器
http://1.2.3.4:18080
```

使用 UI token 登录。

## A.6 安全注意事项

无 TLS 代表 token 与终端数据明文传输，仅建议测试环境使用。  
可用防火墙限制来源 IP：

```bash
ufw allow from 203.0.113.50 to any port 18080
ufw allow from 198.51.100.10 to any port 18080
ufw deny 18080/tcp
```

---

下一步：
- 上线部署看 Part 2：`02-tls.md`
- 升级/排障看 Part 3：`03-operations.md`

---

# 公网服务器部署（Part 2）：TLS（域名 / 自签名）

> 适用：生产部署、跨公网长期运行。  
> 本文包含：
> - 方案 B：域名 + Let's Encrypt（推荐）
> - 方案 B'：无域名 + 自签名 TLS

## 方案 B：Nginx + TLS（域名）

### B.1 编译与上传

```bash
cd cc-control
CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o cc-control ./cmd/cc-control

scp cc-control root@1.2.3.4:/opt/cc-control/
scp -r ../ui root@1.2.3.4:/opt/cc-control/ui
```

### B.2 生成 Admin Token

```bash
ADMIN_TOKEN=$(openssl rand -hex 32)
echo "ADMIN_TOKEN=$ADMIN_TOKEN"
```

### B.3 配置并启动 cc-control

`/etc/systemd/system/cc-control.service`：

```ini
[Unit]
Description=CC Control Plane
After=network.target

[Service]
Type=simple
User=cc
Group=cc
WorkingDirectory=/opt/cc-control
ExecStart=/opt/cc-control/cc-control \
  -addr 127.0.0.1:18080 \
  -ui-dir /opt/cc-control/ui \
  -admin-token ${ADMIN_TOKEN} \
  -audit-path /opt/cc-control/audit.jsonl \
  -offline-after-sec 30
EnvironmentFile=/opt/cc-control/.env
Restart=always
RestartSec=3

[Install]
WantedBy=multi-user.target
```

`/opt/cc-control/.env`（600）：

```bash
ADMIN_TOKEN=<your-admin-token>
```

```bash
useradd -r -s /sbin/nologin cc
chown -R cc:cc /opt/cc-control
chmod 600 /opt/cc-control/.env
systemctl daemon-reload
systemctl enable --now cc-control
```

可选：增加 `-enable-prompt-detection`。

### B.3.1 创建 UI/Agent Token（Admin API）

```bash
# UI token（owner），返回 tenant_id
curl -X POST https://cc.example.com/admin/tokens \
  -H "Authorization: Bearer $ADMIN_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"type":"ui","role":"owner"}'

# Agent token（同 tenant_id）
curl -X POST https://cc.example.com/admin/tokens \
  -H "Authorization: Bearer $ADMIN_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"type":"agent","tenant_id":"<tenant_id>"}'
```

### B.4 配置 Nginx + Let's Encrypt

```bash
apt install -y nginx certbot python3-certbot-nginx
certbot --nginx -d cc.example.com
```

`/etc/nginx/conf.d/cc.conf`：

```nginx
server {
    listen 443 ssl http2;
    server_name cc.example.com;

    ssl_certificate     /etc/letsencrypt/live/cc.example.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/cc.example.com/privkey.pem;

    location /ws/ {
        proxy_pass http://127.0.0.1:18080;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_read_timeout 3600s;
        proxy_send_timeout 3600s;
    }

    location / {
        proxy_pass http://127.0.0.1:18080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}

server {
    listen 80;
    server_name cc.example.com;
    return 301 https://$host$request_uri;
}
```

```bash
nginx -t && systemctl reload nginx
ufw allow 80/tcp
ufw allow 443/tcp
ufw enable
```

### B.5 部署 cc-agent

```bash
cd cc-agent
CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o cc-agent ./cmd/cc-agent
scp cc-agent user@internal-host:/opt/cc-agent/
```

`/etc/systemd/system/cc-agent.service`：

```ini
[Unit]
Description=CC Agent
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
User=deploy
Group=deploy
WorkingDirectory=/opt/cc-agent
ExecStart=/opt/cc-agent/cc-agent \
  -control-url wss://cc.example.com/ws/agent \
  -agent-token ${AGENT_TOKEN} \
  -server-id ${SERVER_ID} \
  -allow-root /home/deploy/repos \
  -claude-path /path/to/ai-cli
EnvironmentFile=/opt/cc-agent/.env
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
```

`/opt/cc-agent/.env`（600）：

```bash
AGENT_TOKEN=<agent-token-from-admin-api>
SERVER_ID=srv-gpu-01
```

```bash
chmod 600 /opt/cc-agent/.env
systemctl daemon-reload
systemctl enable --now cc-agent
```

### B.6 验证

```bash
journalctl -u cc-agent -f
```

浏览器访问 `https://cc.example.com`，使用 UI token 登录。

---

## 方案 B'：无域名 + 自签名 TLS

### B'.1 生成自签名证书（含 IP SAN）

将 `1.2.3.4` 替换为你的公网 IP。

```bash
mkdir -p /opt/cc-control/tls
cd /opt/cc-control/tls

cat > openssl.cnf << 'EOF'
[req]
distinguished_name = req_distinguished_name
req_extensions = v3_req
prompt = no
[req_distinguished_name]
CN = cc-control
[v3_req]
subjectAltName = @alt
[alt]
IP.1 = 1.2.3.4
EOF

openssl req -x509 -nodes -days 3650 -newkey rsa:2048 \
  -keyout key.pem -out cert.pem -config openssl.cnf -extensions v3_req
```

### B'.2 cc-control 与方案 B 相同

按 B.1～B.3 配置 `cc-control`（仍使用 `-admin-token`）。

### B'.3 Nginx 使用自签名证书

`/etc/nginx/conf.d/cc.conf`：

```nginx
server {
    listen 443 ssl http2 default_server;
    listen [::]:443 ssl http2 default_server;
    server_name _;

    ssl_certificate     /opt/cc-control/tls/cert.pem;
    ssl_certificate_key /opt/cc-control/tls/key.pem;

    location /ws/ {
        proxy_pass http://127.0.0.1:18080;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_read_timeout 3600s;
        proxy_send_timeout 3600s;
    }

    location / {
        proxy_pass http://127.0.0.1:18080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

```bash
nginx -t && systemctl reload nginx
ufw allow 443/tcp
ufw enable
```

### B'.4 cc-agent 需跳过证书校验

```bash
/opt/cc-agent/cc-agent \
  -control-url wss://1.2.3.4/ws/agent \
  -tls-skip-verify \
  -agent-token "<agent-token>" \
  -server-id srv-gpu-01 \
  -allow-root /home/deploy/repos \
  -claude-path /path/to/ai-cli
```

Systemd 场景可在 `.env` 中设置 `TLS_SKIP_VERIFY=1`。

### B'.5 验证

- 浏览器访问 `https://1.2.3.4`，先接受证书警告，再用 UI token 登录
- `journalctl -u cc-agent -f` 观察 agent 连接状态

---

下一步：
- 客户端接入、安全加固、批量部署、升级迁移请看 Part 3：`03-operations.md`

---

# 公网服务器部署（Part 3）：客户端接入、运维与升级

> 本文包含：
> - 客户端连接（macOS App / Browser）
> - 安全加固清单
> - 多 Agent 批量部署
> - 旧版本破坏性升级（legacy -> admin-token）
> - 常见故障排查

## 1. 客户端连接

### 1.1 macOS 原生客户端

`app/AgentControlMac` 可连接任意已部署的 `cc-control`。

1. 打开应用，按 `Cmd+,` 进入 Settings
2. 填写：
   - Base URL
     - 直连：`http://公网IP:18080`
     - 域名 TLS：`https://cc.example.com`
     - 自签名 TLS：`https://公网IP`（勾选 Skip TLS verification）
   - UI Token：由 Admin API 创建
3. 点击 Save & Reconnect

### 1.2 浏览器

- 直连：`http://公网IP:18080`
- 域名 TLS：`https://cc.example.com`
- 自签名 TLS：`https://公网IP`（先手动信任证书）

登录均使用 UI token。

## 2. 安全加固清单

| 项目 | 方案 A (无 TLS) | 方案 B (域名 TLS) | 方案 B' (自签名 TLS) |
|------|----------------|-------------------|----------------------|
| 传输加密 | 无，token 明文 | TLS 加密 | TLS 加密 |
| Token | 强随机，防火墙限源 IP | 强随机即可 | 强随机即可 |
| allow-root | 严格限制到项目目录 | 同左 | 同左 |
| 运行用户 | 非 root | 同左 | 同左 |
| 端口暴露 | 防火墙限源 IP | 仅 80/443 | 仅 443 |
| UI 访问限制 | 防火墙限源 IP | Nginx IP 白名单 / Basic Auth | 同左 |
| 日志审计 | `audit.jsonl` 定期归档 | 同左 | 同左 |
| 证书 | — | Let's Encrypt | 自签名，agent 用 `-tls-skip-verify` |

## 3. 多 Agent 批量部署（可选）

```bash
for host in gpu01 gpu02 gpu03; do
  scp cc-agent $host:/opt/cc-agent/
  ssh $host "cat > /opt/cc-agent/.env << EOF
AGENT_TOKEN=<agent-token-from-admin-api>
SERVER_ID=srv-$host
EOF
chmod 600 /opt/cc-agent/.env
systemctl daemon-reload
systemctl enable --now cc-agent"
done
```

## 4. 旧版本破坏性升级（legacy token -> admin token）

适用于旧部署使用 `-ui-token/-agent-token`，并允许短暂中断。

### 4.1 备份

```bash
TS=$(date +%Y%m%d-%H%M%S)
mkdir -p ~/cc-upgrade-backup/$TS
sudo cp /opt/cc-control/cc-control ~/cc-upgrade-backup/$TS/cc-control.bin.bak
sudo cp /etc/systemd/system/cc-control.service ~/cc-upgrade-backup/$TS/cc-control.service.bak
sudo cp /opt/cc-control/.env ~/cc-upgrade-backup/$TS/cc-control.env.bak
```

### 4.2 切到 `-admin-token` 启动

`/etc/systemd/system/cc-control.service` 核心参数：

```ini
ExecStart=/opt/cc-control/cc-control \
  -addr 127.0.0.1:18080 \
  -ui-dir /opt/cc-control/ui \
  -admin-token ${ADMIN_TOKEN} \
  -audit-path /opt/cc-control/audit.jsonl \
  -offline-after-sec 30
```

`/opt/cc-control/.env`：

```bash
ADMIN_TOKEN=<your-admin-token>
```

重启：

```bash
sudo systemctl daemon-reload
sudo systemctl reset-failed cc-control || true
sudo systemctl restart cc-control
curl -sS http://127.0.0.1:18080/api/healthz
```

### 4.3 签发新 token

```bash
# UI token + tenant_id
curl -X POST https://<control-host>/admin/tokens \
  -H "Authorization: Bearer $ADMIN_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"type":"ui","role":"owner"}'

# Agent token（同 tenant）
curl -X POST https://<control-host>/admin/tokens \
  -H "Authorization: Bearer $ADMIN_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"type":"agent","tenant_id":"<tenant_id>"}'
```

说明：
- token 为内存态，`cc-control` 重启后需重新签发或外部管理。
- 切换后 `servers` 为空通常是 agent 仍使用旧 token。

### 4.4 逐台重启 agent

```bash
/opt/cc-agent/cc-agent \
  -control-url wss://<control-host>/ws/agent \
  -agent-token "<new-agent-token>" \
  -server-id srv-gpu-01 \
  -allow-root /home/deploy/repos \
  -claude-path /path/to/ai-cli
```

自签名 TLS 场景加 `-tls-skip-verify`。

### 4.5 回滚（可选）

```bash
TS=<backup-ts>
sudo cp ~/cc-upgrade-backup/$TS/cc-control.bin.bak /opt/cc-control/cc-control
sudo cp ~/cc-upgrade-backup/$TS/cc-control.service.bak /etc/systemd/system/cc-control.service
sudo cp ~/cc-upgrade-backup/$TS/cc-control.env.bak /opt/cc-control/.env
sudo systemctl daemon-reload
sudo systemctl restart cc-control
```

## 5. 故障排查

```bash
# control 监听
ss -tlnp | grep 18080

# agent 连接日志
journalctl -u cc-agent --since "5 min ago"

# nginx 代理
curl -v https://cc.example.com/api/servers

# 防火墙
ufw status
```

---

相关文档：
- Part 1（直连部署）：`01-direct-http.md`
- Part 2（TLS 部署）：`02-tls.md`
    </script>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        
        // Configure marked with highlight.js
        marked.setOptions({
            highlight: function(code, lang) {
                if (lang && hljs.getLanguage(lang)) {
                    return hljs.highlight(code, { language: lang }).value;
                }
                return hljs.highlightAuto(code).value;
            },
            breaks: true
        });

        // Initialize mermaid
        mermaid.initialize({ startOnLoad: false, theme: 'dark', themeVariables: { darkMode: true, background: '#000000', primaryColor: '#2563eb' } });

        // Render markdown
        const markdownSource = document.getElementById('markdown-source').textContent;
        const contentDiv = document.getElementById('markdown-body');
        contentDiv.innerHTML = marked.parse(markdownSource);

        // Render mermaid diagrams
        const mermaidBlocks = contentDiv.querySelectorAll('.language-mermaid');
        mermaidBlocks.forEach(async (block, index) => {
            const graphDefinition = block.textContent;
            const newDiv = document.createElement('div');
            newDiv.className = 'mermaid';
            newDiv.textContent = graphDefinition;
            block.parentNode.replaceWith(newDiv);
        });
        
        mermaid.run();
    </script>
</body>
</html>
